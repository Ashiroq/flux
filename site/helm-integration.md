---
title: Using Flux with Helm
menu_order: 90
---

# Using Flux with Helm

You can release charts to your cluster via "GitOps", by combining Flux
and the Flux Helm Operator (also in
[weaveworks/flux](https://github.com/weaveworks/flux)).

The essential mechanism is this: the declaration of a Helm release is
represented by a custom resource, specifying the chart and its
values. If you put such a resource in your git repo as a file, Flux
will apply it to the cluster, and once it's in the cluster, the Helm
Operator will make sure the release exists by installing or upgrading
it.

## The `FluxHelmRelease` custom resource

Each release of a chart is declared by a `FluxHelmRelease`
resource. The schema for these resources is given in [the custom
resource definition](../deploy-helm/flux-helm-release-crd.yaml). They
look like this:

```yaml
---
apiVersion: flux.weave.works/v1beta1
kind: FluxHelmRelease
metadata:
  name: rabbit
  namespace: default
spec:
  releaseName: rabbitmq
  chart:
    repository: https://kubernetes-charts.storage.googleapis.com/
    name: rabbitmq
    version: 3.3.6
  values:
    replicas: 1
```

The `releaseName` will be given to Helm as the release name. If not
supplied, it will be generated by affixing the namespace to the
resource name. In the above example, if `releaseName` were not given,
it would be generated as `default-rabbitmq`. Because of the way Helm
works, release names must be unique in the cluster.

The `chart` section gives a pointer to the chart; in this case, to a
chart in a Helm repo. Since the helm operator is running in your
cluster, and doesn't have access to local configuration, the
repository is given as a URL rather than an alias (the URL in the
example is what's usually aliased as `stable`). The `name` and
`version` specify the chart to release.

The `values` section is where you provide the value overrides for the
chart. This is as you would put in a `values.yaml` file, but inlined
into the structure of the resource. See below for examples.

### Using a chart from a Git repo instead of a Helm repo

You can refer to a chart from a _git_ repo, rather than a chart repo,
with a `chart:` section like this:

```yaml
spec:
  chart:
    gitRepository: git@github.com:weaveworks/flux
    ref: master
    path: charts/flux
```

In this case, the git repo will be cloned, and the chart will be
released from the ref given (which defaults to `master`, if not
supplied). Commits to the git repo may result in releases, if they
update the chart at the path given.

### What the Helm Operator does

When the Helm Operator sees a `FluxHelmRelease` resource in the
cluster, it either installs or upgrades the named Helm release so that
the chart is released as specified.

It will also notice when a `FluxHelmRelease` resource is updated, and
take action accordingly.

## Supplying values to the chart

You can supply values to be used with the chart when installing it, in
two ways.

### `.spec.values`

This is a YAML map as you'd put in a file and supply to Helm with `-f
values.yaml`, but inlined into the FluxHelmRelease manifest. For
example,

```yaml
apiVersion: flux.weave.works/v1beta1
kind: FluxHelmRelease
# metadata: ...
spec:
  # chart: ...
  values:
    foo: value1
    bar:
    baz: value2
    oof:
    - item1
    - item2
```

### `.spec.valueFileSecrets`

This is a list of secrets (in the same namespace as the
FluxHelmRelease) from which to take values. The secrets must each
contain an entry for `values.yaml`.

The values are merged in the order given, with later values
overwriting earlier. These values always have a lower priority that
those passed via the `.spec.values` parameter.

This is useful if you want to have defaults such as the `region`,
`clustername`, `environment`, a local docker registry URL, etc., or if
you simply want to have values not checked into git as plaintext.

#### Example of `spec.valueFileSecrets`

Say you have a values.yaml that looks like this:

```yaml
# values.yaml
clusterName: "my-cluster"
dockerRegistry: "registry.local"
mySecretValue: "foo"
```

You would create a secret in the cluster by doing this:

```sh
kubectl -n dev create secret generic default-values --from-file=values.yaml
```

If you did `kubectl get -n dev default-values` you would get:

```yaml
apiVersion: v1
kind: Secret
type: Opaque
metadata:
  name: default-values
  namespace: dev
data:
  values.yaml: <base64 encoded values.yaml>
```

Then, you could refer to the secret in a `FluxHelmRelease`, and the
values would be used when the chart was installed:

```yaml
apiVersion: flux.weave.works/v1beta1
kind: FluxHelmRelease
metadata:
  name: uses-secret
  namespace: dev
spec:
  # chart: ...
  valueFileSecrets:
  - name: "default-values"
```

## Supplying credentials with chartPullSecrets

### Authentication for Helm repos

At some point you will likely need a private Helm repo for your own
charts, and this will usually require some authentication.

To let the Helm Operator download charts from a private Helm repo, you
can use the field `chartPullSecret` to refer to a Kubernetes secret
holding credentials to the chart repository or repositories.

The format of the secret is that it has at least one entry,
`repositories.yaml`, which has the content of a `repositories.yaml`
file such as `helm` maintains in
`$HOME/.helm/repository/repositories.yaml`. If that refers to any
certificate or key files, those should be in the same directory and
included as entries in the secret.

<a name="cite-why-repo-urls"></a>The names given in
`repositories.yaml` do not have significance; it's the URLs that will
be used to find credentials, since it's a repository URL that is given
in the `FluxHelmRelease`[*](#why-repo-urls).

### Authentication for Git repos

In general, it's necessary to have an SSH key to clone a git
repo. This is sometimes (e.g., on GitHub) called a "deploy key". To
use a chart from git, the Helm Operator needs a key with read-only
access.

To provide an SSH key, put the key in a secret under the entry
`"identity"`, and refer to that secret as the `chartPullSecret` in the
`FluxHelmRelease`.

## Upgrading images in a FluxHelmRelease using Flux

If the chart you're using in a FluxHelmRelease lets you specify the
particular images to run, you will usually be able to update them with
Flux, the same way you can with Deployments and so on.

Flux interprets certain commonly used structures in the `values`
section of a `FluxHelmRelease` as referring to images. The following
are understood (showing just the `values` section):

```yaml
values:
  image: repo/image:version
```

```yaml
values:
  image: repo/image
  tag: version
```

```yaml
values:
  image:
    repository: repo/image
    tag: version
```

These can appear at the top level (immediately under `values:`), or in
a subsection (under a key, itself under `values:`). Other values
may be mixed in arbitrarily. Here's an example of a values section
that specifies two images, along with some other configuration:

```yaml
values:
  persistent: true

  # image that will be labeled "chart-image"
  image: repo/image1:version

  subsystem:
    # image that will be labeled "subsystem"
    image:
      repository: repo/image2
      tag: version
      imagePullPolicy: IfNotPresent
    port: 4040
```

### Using annotations to control updates to FluxHelmRelease resources

You can use the [same annotations](./using.md#using-annotations) in
the `FluxHelmRelease` as you would for a Deployment or other workload,
to control updates and automation. For the purpose of specifying
filters, the container name is either `chart-image` (if at the top
level), or the key under which the image is given (e.g., `"subsystem"`
from the example above).

-------------

<a name="why-repo-urls">**Why use URLs to refer to repositories, rather than names?**</a> [^](#cite-why-repo-urls)

A `FluxHelmRelease` must be able to stand on its own. If we used names
in the spec, which were resolved to URLs elsewhere (e.g., in a
`repositories.yaml` supplied to the operator), it would be possible to
change the meaning of a `FluxHelmRelease` without altering it. This is
undesirable because it makes it hard to specify exactly what you want,
in the one place; or to read exactly what is being specified, in the
one place. In other words, it's better to be explicit.
